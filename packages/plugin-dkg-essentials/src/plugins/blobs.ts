import { Readable, Writable } from "stream";
import consumers from "stream/consumers";
import { defineDkgPlugin } from "@dkg/plugins";
import { z, openAPIRoute } from "@dkg/plugin-swagger";
import { ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";
import busboy from "busboy";

export default defineDkgPlugin((ctx, mcp, api) => {
  mcp.registerTool(
    "upload",
    {
      title: "Upload File",
      description:
        "Upload a file to the MCP server that can later be accessed by other plugins through DKG context",
      inputSchema: {
        filename: z.string().describe("Filename"),
        fileBase64: z.string().describe("Base64 encoded file content"),
        mimeType: z.string().optional(),
      },
    },
    async ({ fileBase64, filename, mimeType }) => {
      const buffer = Buffer.from(fileBase64, "base64");
      const { id } = await ctx.blob.create(
        Readable.toWeb(Readable.from(buffer)),
        {
          name: filename,
          mimeType,
        },
      );

      return {
        content: [
          {
            type: "text",
            text: "File was successfully uploaded with ID: " + id,
          },
        ],
      };
    },
  );

  mcp.registerResource(
    "blob",
    new ResourceTemplate("dkg-blob://{id}", { list: undefined }),
    {
      title: "Blob",
      description: "A blob resource",
    },
    async (uri) => {
      const blob = await ctx.blob.get(
        uri.toString().substring("dkg-blob://".length),
      );
      if (!blob) throw new Error("Resource not found");
      const text = await consumers.text(blob.data);

      return {
        contents: [{ uri: uri.toString(), text }],
      };
    },
  );

  api.post(
    "/blob",
    openAPIRoute(
      {
        summary: "Upload file to MCP Server",
        description:
          "Used for uploading files to the MCP Server blob storage " +
          "to later be used in the tool calls via generated id",
        tag: "Blobs",
        response: {
          schema: z.object({
            id: z.string().openapi({
              description: "The unique identifier of the stored blob",
              example: "b931b43f-76be-4289-a44e-bbc87286bd2e_my-doc.pdf",
            }),
            name: z.string().openapi({
              description:
                "The name of the file, used for displaying in the UI",
              example: "my-doc.pdf",
            }),
            mimeType: z.string().openapi({
              description: "The MIME type of the file",
              example: "application/pdf",
            }),
          }),
        },
        finalizeRouteConfig(cfg) {
          cfg.request = {
            body: {
              required: true,
              description: "File data",
              content: {
                "multipart/form-data": {
                  schema: z.object({
                    file: z.string().openapi({
                      description: "The file to be uploaded",
                      format: "binary",
                    }),
                  }),
                },
              },
            },
          };
          return cfg;
        },
      },
      async (req, res) => {
        const bb = busboy({ headers: req.headers });
        bb.on("file", async (name, file, info) => {
          if (name !== "file")
            return res.status(400).json({ error: "Invalid file name" });

          try {
            const { id } = await ctx.blob.create(Readable.toWeb(file), {
              name: info.filename,
              mimeType: info.mimeType,
            });
            res
              .status(201)
              .json({ id, name: info.filename, mimeType: info.mimeType });
          } catch (error) {
            console.error(error);
            res.status(500).json({ error: `Failed to create blob: ${error}` });
          }
        });
        req.pipe(bb);
      },
    ),
  );

  api.get(
    "/blob/:id",
    openAPIRoute(
      {
        summary: "Get a blob",
        description: "Retrieve a blob (file) by its ID. Downloads the file.",
        tag: "Blobs",
        params: z.object({
          id: z.string().openapi({
            description:
              "Blob ID which was generated by the server during upload",
          }),
        }),
      },
      async (req, res) => {
        const obj = await ctx.blob.get(req.params.id);
        if (!obj) return res.status(404).json({ error: "Blob not found" });

        if (obj.metadata.mimeType) {
          res.setHeader("Content-Type", obj.metadata.mimeType);
        }
        res.setHeader(
          "Content-Disposition",
          `attachment; filename="${obj.metadata.name}"`,
        );
        res.status(200);

        return obj.data.pipeTo(Writable.toWeb(res));
      },
    ),
  );

  api.put(
    "/blob/:id",
    openAPIRoute(
      {
        summary: "Update/create a blob",
        description:
          "Update a file with the given ID or create a new file with the given ID.",
        tag: "Blobs",
        params: z.object({
          id: z.string().openapi({
            description:
              "Blob ID which was generated by the server during upload",
          }),
        }),
        finalizeRouteConfig(cfg) {
          cfg.request = {
            params: cfg.request?.params,
            body: {
              required: true,
              description: "File",
              content: {
                "multipart/form-data": {
                  schema: z.object({
                    file: z.string().openapi({
                      description: "The file to be uploaded",
                      format: "binary",
                    }),
                  }),
                },
              },
            },
          };
          return cfg;
        },
      },
      async (req, res) => {
        const bb = busboy({ headers: req.headers });
        bb.on("file", async (name, file, info) => {
          if (name !== "file")
            return res.status(400).json({ error: "Invalid file name" });

          try {
            await ctx.blob.put(req.params.id, Readable.toWeb(file), {
              name: info.filename,
              mimeType: info.mimeType,
            });
            res.status(200).send();
          } catch (error) {
            console.error(error);
            res.status(500).json({ error: `Failed to update blob: ${error}` });
          }
        });
        req.pipe(bb);
      },
    ),
  );

  api.delete(
    "/blob/:id",
    openAPIRoute(
      {
        summary: "Delete a blob",
        description: "Delete a blob (file) by its ID.",
        tag: "Blobs",
        params: z.object({
          id: z.string().openapi({
            description:
              "Blob ID which was generated by the server during upload",
          }),
        }),
      },
      async (req, res) => {
        try {
          await ctx.blob.delete(req.params.id);
          res.status(200).send();
        } catch (error) {
          console.error(error);
          res.status(500).json({ error: `Failed to delete blob: ${error}` });
        }
      },
    ),
  );
});
